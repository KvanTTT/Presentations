## Workflow

Прежде всего, что такое Паттерн?
Паттерн - фрагмент кода. В нашем случае все паттерны описывают какие-либо уязвимости в исходном коде.
В начале я опишу этапы работы нашего ядра паттерн-матчинга или PM. Это:

1. Парсинг в зависимое от языка AST
2. Преобразование AST в унифицированный формат.
3. Непосредственно паттерн-матчинг.

Для чего нужно такое разбиение?
Для того, чтобы была возможность описания паттернов под разные языки с помощью одного и того же подхода.
Далее я буду описывать каждый этап работы подробно. Первым этапом является парсинг кода.

## Теория парсинга

Парсинг - процесс преобразования исходного кода в структурированный вид.

Типичный парсер на самом деле представляет собой комбинацию так называемого лексера и парсера.
Лексер группирует символы исходного кода в значащие последовательности, которые называются токенами.
В данном примере токенами являются sp, =, 100. А вообще:  Id, String, Integer, Keyword (If, While, For), скобки и т.д.
А затем парсер уже из потока токенов строит связную древовидную структуру, которая называется деревом разбора.
В данном случае assign является одним из узлов дерева.
Абстрактное синтаксическое дерево или AST - дерево разбора на более высоком уровне, из которого удалены не значимые токены, такие как скобки, запятые и т.д.

Для описания различных узлов AST дерева используются правила. Объединение всех правил называют грамматикой языка.

Существуют инструменты, генерирующие код для разбора языков на основе грамматик.
Они называются генераторами парсеров. Например, ANTLR, Bison, Coco/R.

## Проблематика парсера

При разработке парсеров существуют некоторые проблемы, решение которых нужно продумать.
Они перечислены в данном слайде.
Одной из таких проблем является распознавание ключевых слов как идентификаторов,
для этого достаточно объявить правило, которое содержит в себе подправило для обычного ID и токенов,
которые распознались как ключевые слова.

Другой проблемой является обработка комментариев.
Неудобством в этом случае является то, что если включать комментарии в строящееся AST,
то оно получится переусложненным, так как по сути каждый узел будет содержать в себе комментарии.
Однако просто выкинуть комментарии также нельзя, потому что в них может содержаться уязвимость,
как продемонстрировано здесь во втором примере.
Для обработки комментариев в ANTLR используются так называемые каналы,
которые изолируют множество комментариев от остальных токенов.

Также важной способностью каждого парсера является обработка ошибок. Почему она важна?
Чтобы, например, процесс парсинга не прерывался только из-за одной точки с запятой.
И для того, чтобы вместо тысячи ошибок генерировалась только одна (Тут можно привести в пример C++).

## Типичные ошибки парсинга

На этом слайде отображены примеры частовстречающихся ошибок парсинга.

* Это ошибка на лексическом уровне при распознавании токена.
* Ошибка лишнего токена (парсер удаляет токен, вставляет узел с типой "ошибка" и продолжает дальнейшую работу),
* отсутствующего токена (парсер вставляет токен),
* нескольких лишних токенов (парсер прекращает работу, ожидает токена из так называемого синхронизирущего множества, например, точку с запятой). Это позволяет детектировать одну ошибку вместо множества.
* и отсутствие подходящего альтернативного подправила.

## Виды грамматик

В настоящее время практически весь синтаксис современных ЯП можно описать с помощью КС грамматик.
О грамматиках вам было рассказано выше. Хочу лишь добавить, что если говорить простыми словами,
то если сравнивать КС-языки и регулярные выражения, то последние не имеют памяти (не умеют считать).
А если сравнивать КЗ и КС-языки, то последние не запоминают посещенные ранее правила
(Из-за этого они умеют считать две вещи, а не множество).

Также язык в одном случае может являться КС, а в другом - КЗ. Если на этапе парсинга проверяется семантика,
т.е. согласованность с определениями языка, в частности, согласованность типов, то язык может рассматриваться как КЗ.
Однако существуют синтаксическое конструкции, которые никаких не выразить в КС-форме, например Heredoc в PHP.

## От теории к практике: грамматика PHP

Для нашего парсера и конвертера PHP была разработана и выложена в опенсорс грамматика,
которая является полным и наглядным применением вышеизложенной теории на практике.
Стоит отметить, что, несмотря на то, что ANTLR поддерживает только КС-грамматики,
в нем существует так называемые экшены, т.е. вставки произвольного кода, которые расширяют допустимое множество языков до тьюринг-полных. С помощью таких вставок была реализована обработка таких сложных конструкций,
как Heredoc и Alternative Syntax (синтаксически-связаные участки PHP кода в перемешку с HTML).

## Технологии парсинга кода в .NET

* Для парсинга C\#  в нашем проекте используется Roslyn,
  так как он является все же нативным для .NET,
  быстрым и опенсорсным средством, поддерживаемым Microsoft.
* Для всех остальных языков, в частности, для Java и PHP, используется ANTLR.

## Visitor vs Listener (Walker)

Перейдем к этапу преобразования AST в унифицированный формат. Для обхода AST существует две стратегии: Visitor и Listener (или Walker в Roslyn).
Разница между ними состоит в том, что в Visitor необходимо в ручную вызывать методы обхода потомков синтаксических узлов,
а в Listener все узлы обходятся автоматически.
Более того, в Visitor возможно возвращать значение при обходе.
Таким образом, код преобразования дерева с помощью Visitor получается более функциональным и лаконичным (потому что не использутеся глобальный стэк).
На рисунке видим, что, например, при преобразовании языка PHP, ненужные узлы HTML и CSS отсекаются.

## Преобразование AST

На этом слайде описан пример метода-визитора VisitIfStatement.
В комментариях описано правило соответствующего узла, который посещается визитором.
AstNode - тип узла унифицированного дерева.

## Структура типов унифицированного AST

Все узлы унифицированного дерева являются наследниками AstNode.
Особое внимание стоит уделить Expression, Statement и Literal.

* Expression - обычное ариметическое выражение, вызов метода, обращение к члену объекта и тд.
* Literal - примитивное строковое, числовое или другое значение.
* Statement - выражения, заканчивающиеся точкой с запятой в типичных ЯП.
  Будет использоваться главным образом для тайнта. злы с приставкой Pattern -
  являются искусственными и предназначены для того, чтобы при обработке матчить
  не просто одно литеральное значение или выражение, а целое множество.
  Например, литерал по регулярному выражению или диапазону чисел.

## Алгоритм сопоставления в AST

На этом слайде описаны основные принципы сравнения узлов в AST для паттерн-матчинга. Паттерн по сути представляет собой кусочек AST.
При обходе унифицированного AST (оно обходится в глубину), каждый кусочек "пытается" наложится на кусочек AST текущего узла.
В начале сравнивается тип узла. В зависимости от типа существует 4 типа сравнений:

1. Рекурсивное сравнение потомков.
2. Сравнение простых литеральных типов (идентификатор, строки, числа).
3. Сравнение расширенных литеральных типов (регулярные выражения, диапазоны). Комментарии входят в эту группу.
4. Сравнение сложных расширенны типов (выражения, последовательность Statement).

Благодаря разработанной технологии матчинга (представление типа узла в виде Enum (то есть целого числа), удалось достигнуть высокой производительности при сравнительно небольшом количестве кода и простых алгоритмах (метод Compare реализован для базового класса и терминалов).

## Язык описания паттернов

Все паттерны или "кусочки дерева" необходимо загружать в программу каким-либо образом.
И на этом слайде описаны подходы для описания паттернов.

* Во-первых, паттерны можно записывать в ручную прямо в коде (что делается у нас и в других ядрах).
  Для этого не требуется разрабатывать какой-либо парсер. Конечно, данный подход
  не подходит для записи паттернов "не программистом", однако может использоваться
  для написания юнит-тестов. Кроме того, для внесения новых паттернов, требуется
  перекомпиляция всей программы.
* Во-вторых, паттерны можно представлять в распространненом формате JSON.
  При этом подходе паттерны можно загружать извне, однако при этом синтаксис
  будет громоздким и неприемлимым для редактирования   человеком. Однако данный
  формат можно использовать для сериализации древесных структур (сохранения и загрузки с диска).
* И, наконец, третий подход заключается в разарботке специального
  предметно-ориентированного языка (или DSL), который можно было бы легко
  редактировать, который был бы лаконичным, но который при этом обладал
  достаточной выразительной мощностью для описания существующих и будущих паттернов.
  Недостатком такого подхода является разработка синтаксиса, а потом и парсера для такого языка.

## Целесообразность DSL?

Часто нам задают вопрос, а нужен ли наш собственный DSL, если существуют регулярные выражения?
Зачем еще один 15 формат?

## DSL ≠ Regex

Ну да, конечно он нужен! Поскольку DSL - это больше, чем регулярные выражения, это регулярные выражения с синтаксическими конструкциями,
похожие на конструкции из стандартных языков программирования.
С помощью регулярок тяжело записывать длинные и хоть сколько-нибудь сложные выражения.
Ну и у DSL название говорит само за себя: это язык, предназначенный для конкретной предметной области, он внутренний и не будет использовать в качестве какого-либо стандарта.

## Синтаксические конструкции в DSL

Примерами таких конструкций являются: вызов метода, обращения к члену объекта, инициализации переменной ....
На этом слайде в эти конструкции вставлены такие аббревеатуры, как expr, args и Id.

## Типы значений в DSL и Синтаксис DSL

Прежде всего expr, или expression может являться обыкновенным примитивным значением типа. Однако если нужно матчить не просто один идентификатор или число, а строку, идентификатор по регулярному выражению или диапазон чисел, то необходимо воспользоваться так называемым расширенным выражением, которое обособляется специальными скобками <[]>.

Также в нашем DSL для многих частоиспользуемых конструкций предусмотрен сокращенный синтаксис, называемый "синтаксическим сахаром". Например, решетка обозначает любой Expression, три точки - произвольное количество любых аргументов.

Интересными дополнительными конструкциями являются отрицание условия (например, когда требуется, чтобы в качестве аргумента указывалась не строка) и объединение нескольких условий, т.е. логическое ИЛИ для паттернов. Также была введена конструкция для поиска именно по комментариям, а не по коду: Comment.

Стоит отметить, что синтаксис нашего DSL все еще в процессе фидбека, разработки и упрощения.

## DSL примеры

Рассмотрим первый пример:

* Hardcoded Password - справа может стоять любое слово или null. Слева - переменная, либо обращению к члену класса.
* Второй пример демонстрирует вызов конструктора с произвольным количеством аргументов.
* В третьем примере используется диапазон чисел.
* В четвертом - использование логического или (в данном случае к константе).

## DSL примеры

Перейдем к следующему слайду.

* Запись из первого примера позволяет создать паттерны для матчинга комментариев в исходном коде.
* Во втором случае записан пример примитивной SQL инъекции. Слева стоит любая строка, начинающаяся с select не зависимого от регистра (как в SQL). Далее она конкатенируется с любым типом, но только не строкой (например, переменная типа стрин, содержащая в себе точку с запятой и произвольный запрос).
* Cookie Without Secure Attribute демонстриует вызов метода по небезопасной сигнатуре. В этом примере четвертый аргумент отвечает за безопасность.

## DSL примеры

* На следующем слайде первым пунктом идет пустой блок обработки исключения.
* И, наконец, самый интересный из поддерживающихся на текущий момент паттернов является последний Insecure Cookie. Вообще, на самом деле, этот паттерн больше подходит для taint-анализа, однако получилось реализовать и с помощью ядра PM. В нем мы видим прикрепленную переменную cookie, отрицание выражение и множество Statement. Т.е. добавление куки без установленного флага защищенности.

## Тестирование

В разработанном ядре PM мы уделили большое внимание тестированию.

* Во-первых, для всех языков были созданы файлы, содержащие все богаство синтаксических конструкций.
* Во-вторых, наше ядро тестировалось на специально подготовленных файлах без синтаксических ошибок и с ними.
* Также на описанных проектах (WebGoat, phpbb, Yii, Zeno Framework) тестировалась работы парсеров и конвертеров C\#, Java и PHP.

Для демонстрации мы также подготовили видео работы ядра PM в нашем продукте Application Inspector.